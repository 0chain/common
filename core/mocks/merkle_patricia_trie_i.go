// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	context "context"
	io "io"

	mock "github.com/stretchr/testify/mock"

	util "github.com/0chain/common/core/util"
)

// MerklePatriciaTrieI is an autogenerated mock type for the MerklePatriciaTrieI type
type MerklePatriciaTrieI struct {
	mock.Mock
}

// Delete provides a mock function with given fields: path
func (_m *MerklePatriciaTrieI) Delete(path util.Path) (util.Key, error) {
	ret := _m.Called(path)

	var r0 util.Key
	if rf, ok := ret.Get(0).(func(util.Path) util.Key); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(util.Key)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(util.Path) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindMissingNodes provides a mock function with given fields: ctx
func (_m *MerklePatriciaTrieI) FindMissingNodes(ctx context.Context) ([]util.Path, []util.Key, error) {
	ret := _m.Called(ctx)

	var r0 []util.Path
	if rf, ok := ret.Get(0).(func(context.Context) []util.Path); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]util.Path)
		}
	}

	var r1 []util.Key
	if rf, ok := ret.Get(1).(func(context.Context) []util.Key); ok {
		r1 = rf(ctx)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]util.Key)
		}
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = rf(ctx)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetChangeCount provides a mock function with given fields:
func (_m *MerklePatriciaTrieI) GetChangeCount() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// GetChanges provides a mock function with given fields:
func (_m *MerklePatriciaTrieI) GetChanges() (util.Key, []*util.NodeChange, []util.Node, util.Key) {
	ret := _m.Called()

	var r0 util.Key
	if rf, ok := ret.Get(0).(func() util.Key); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(util.Key)
		}
	}

	var r1 []*util.NodeChange
	if rf, ok := ret.Get(1).(func() []*util.NodeChange); ok {
		r1 = rf()
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).([]*util.NodeChange)
		}
	}

	var r2 []util.Node
	if rf, ok := ret.Get(2).(func() []util.Node); ok {
		r2 = rf()
	} else {
		if ret.Get(2) != nil {
			r2 = ret.Get(2).([]util.Node)
		}
	}

	var r3 util.Key
	if rf, ok := ret.Get(3).(func() util.Key); ok {
		r3 = rf()
	} else {
		if ret.Get(3) != nil {
			r3 = ret.Get(3).(util.Key)
		}
	}

	return r0, r1, r2, r3
}

// GetDeletes provides a mock function with given fields:
func (_m *MerklePatriciaTrieI) GetDeletes() []util.Node {
	ret := _m.Called()

	var r0 []util.Node
	if rf, ok := ret.Get(0).(func() []util.Node); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]util.Node)
		}
	}

	return r0
}

// GetNodeDB provides a mock function with given fields:
func (_m *MerklePatriciaTrieI) GetNodeDB() util.NodeDB {
	ret := _m.Called()

	var r0 util.NodeDB
	if rf, ok := ret.Get(0).(func() util.NodeDB); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(util.NodeDB)
		}
	}

	return r0
}

// GetNodeValue provides a mock function with given fields: path, v
func (_m *MerklePatriciaTrieI) GetNodeValue(path util.Path, v util.MPTSerializable) error {
	ret := _m.Called(path, v)

	var r0 error
	if rf, ok := ret.Get(0).(func(util.Path, util.MPTSerializable) error); ok {
		r0 = rf(path, v)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetNodeValueRaw provides a mock function with given fields: path
func (_m *MerklePatriciaTrieI) GetNodeValueRaw(path util.Path) ([]byte, error) {
	ret := _m.Called(path)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(util.Path) []byte); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(util.Path) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPathNodes provides a mock function with given fields: path
func (_m *MerklePatriciaTrieI) GetPathNodes(path util.Path) ([]util.Node, error) {
	ret := _m.Called(path)

	var r0 []util.Node
	if rf, ok := ret.Get(0).(func(util.Path) []util.Node); ok {
		r0 = rf(path)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]util.Node)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(util.Path) error); ok {
		r1 = rf(path)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoot provides a mock function with given fields:
func (_m *MerklePatriciaTrieI) GetRoot() util.Key {
	ret := _m.Called()

	var r0 util.Key
	if rf, ok := ret.Get(0).(func() util.Key); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(util.Key)
		}
	}

	return r0
}

// GetVersion provides a mock function with given fields:
func (_m *MerklePatriciaTrieI) GetVersion() util.Sequence {
	ret := _m.Called()

	var r0 util.Sequence
	if rf, ok := ret.Get(0).(func() util.Sequence); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(util.Sequence)
	}

	return r0
}

// HasMissingNodes provides a mock function with given fields: ctx
func (_m *MerklePatriciaTrieI) HasMissingNodes(ctx context.Context) (bool, error) {
	ret := _m.Called(ctx)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context) bool); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Insert provides a mock function with given fields: path, value
func (_m *MerklePatriciaTrieI) Insert(path util.Path, value util.MPTSerializable) (util.Key, error) {
	ret := _m.Called(path, value)

	var r0 util.Key
	if rf, ok := ret.Get(0).(func(util.Path, util.MPTSerializable) util.Key); ok {
		r0 = rf(path, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(util.Key)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(util.Path, util.MPTSerializable) error); ok {
		r1 = rf(path, value)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Iterate provides a mock function with given fields: ctx, handler, visitNodeTypes
func (_m *MerklePatriciaTrieI) Iterate(ctx context.Context, handler util.MPTIteratorHandler, visitNodeTypes byte) error {
	ret := _m.Called(ctx, handler, visitNodeTypes)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, util.MPTIteratorHandler, byte) error); ok {
		r0 = rf(ctx, handler, visitNodeTypes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IterateFrom provides a mock function with given fields: ctx, node, handler, visitNodeTypes
func (_m *MerklePatriciaTrieI) IterateFrom(ctx context.Context, node util.Key, handler util.MPTIteratorHandler, visitNodeTypes byte) error {
	ret := _m.Called(ctx, node, handler, visitNodeTypes)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, util.Key, util.MPTIteratorHandler, byte) error); ok {
		r0 = rf(ctx, node, handler, visitNodeTypes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MergeChanges provides a mock function with given fields: newRoot, changes, deletes, startRoot
func (_m *MerklePatriciaTrieI) MergeChanges(newRoot util.Key, changes []*util.NodeChange, deletes []util.Node, startRoot util.Key) error {
	ret := _m.Called(newRoot, changes, deletes, startRoot)

	var r0 error
	if rf, ok := ret.Get(0).(func(util.Key, []*util.NodeChange, []util.Node, util.Key) error); ok {
		r0 = rf(newRoot, changes, deletes, startRoot)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MergeDB provides a mock function with given fields: ndb, root
func (_m *MerklePatriciaTrieI) MergeDB(ndb util.NodeDB, root util.Key) error {
	ret := _m.Called(ndb, root)

	var r0 error
	if rf, ok := ret.Get(0).(func(util.NodeDB, util.Key) error); ok {
		r0 = rf(ndb, root)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MergeMPTChanges provides a mock function with given fields: mpt2
func (_m *MerklePatriciaTrieI) MergeMPTChanges(mpt2 util.MerklePatriciaTrieI) error {
	ret := _m.Called(mpt2)

	var r0 error
	if rf, ok := ret.Get(0).(func(util.MerklePatriciaTrieI) error); ok {
		r0 = rf(mpt2)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PrettyPrint provides a mock function with given fields: w
func (_m *MerklePatriciaTrieI) PrettyPrint(w io.Writer) error {
	ret := _m.Called(w)

	var r0 error
	if rf, ok := ret.Get(0).(func(io.Writer) error); ok {
		r0 = rf(w)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SaveChanges provides a mock function with given fields: ctx, ndb, includeDeletes
func (_m *MerklePatriciaTrieI) SaveChanges(ctx context.Context, ndb util.NodeDB, includeDeletes bool) error {
	ret := _m.Called(ctx, ndb, includeDeletes)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, util.NodeDB, bool) error); ok {
		r0 = rf(ctx, ndb, includeDeletes)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetNodeDB provides a mock function with given fields: ndb
func (_m *MerklePatriciaTrieI) SetNodeDB(ndb util.NodeDB) {
	_m.Called(ndb)
}

// SetVersion provides a mock function with given fields: version
func (_m *MerklePatriciaTrieI) SetVersion(version util.Sequence) {
	_m.Called(version)
}

// UpdateVersion provides a mock function with given fields: ctx, version, missingNodeHander
func (_m *MerklePatriciaTrieI) UpdateVersion(ctx context.Context, version util.Sequence, missingNodeHander util.MPTMissingNodeHandler) error {
	ret := _m.Called(ctx, version, missingNodeHander)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, util.Sequence, util.MPTMissingNodeHandler) error); ok {
		r0 = rf(ctx, version, missingNodeHander)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Validate provides a mock function with given fields:
func (_m *MerklePatriciaTrieI) Validate() error {
	ret := _m.Called()

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

type mockConstructorTestingTNewMerklePatriciaTrieI interface {
	mock.TestingT
	Cleanup(func())
}

// NewMerklePatriciaTrieI creates a new instance of MerklePatriciaTrieI. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewMerklePatriciaTrieI(t mockConstructorTestingTNewMerklePatriciaTrieI) *MerklePatriciaTrieI {
	mock := &MerklePatriciaTrieI{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
